"""
Agentic Auditor for R2Bit TripAudit.

This module implements a LangGraph workflow that processes expense report summaries
and generates approval emails using OpenAI models.

The workflow consists of three main steps:
1. Analyze the expense summary data
2. Generate an approval email using OpenAI
3. Handle any errors that occur during processing

The module uses LangGraph to create a directed graph of these processing steps,
with conditional edges that determine the flow based on the state of the workflow.
"""

# Standard library imports
import os          # For file and environment operations
import sys         # For path manipulation and command-line arguments
import json        # For parsing and generating JSON data
import traceback   # For detailed error information
from typing import Dict, TypedDict, List, Optional, Annotated, Any  # Type hints for better code clarity
from pathlib import Path  # Object-oriented filesystem paths

# Add parent directory to path to import from src
# This is necessary because Python imports are relative to the script's location
# This approach allows us to import modules from the parent directory
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Third-party imports
from openai import OpenAI  # OpenAI API client for generating email content
from langgraph.graph import StateGraph, END  # LangGraph for workflow orchestration
from dotenv import load_dotenv  # For loading environment variables from .env file

# Local application imports
from audit_expenses import ExpenseAuditor  # Our custom module for expense auditing

# Load environment variables from .env file
# This loads API keys and other configuration from a .env file in the project root
project_root = Path(__file__).parent.parent.parent.absolute()  # Get absolute path to project root
load_dotenv(os.path.join(project_root, '.env'))  # Load variables from .env file


# Define proper state schema for LangGraph compliance
# TypedDict allows us to define dictionary-like classes with specific key types
# This helps with type checking and code clarity
class WorkflowState(TypedDict):
    """Represents the complete state of the workflow at any point in time.
    
    This class defines the structure of the state object that flows through the
    LangGraph workflow. Each node in the graph can read from and write to this state.
    """
    expense_summary: Dict[str, Any]  # Contains the expense report data and analysis
    email_content: Dict[str, Any]    # Contains the generated email content
    error: str                       # Contains any error messages that occur


class ExpenseSummary(TypedDict):
    """Represents the summary of an expense report after processing.
    
    This class defines the structure of the expense summary data that is
    passed into the workflow from the ExpenseAuditor.
    """
    pdf_path: str                # Path to the original PDF file
    processed_dir: str           # Directory where processed files are stored
    text_report_path: str        # Path to the generated text report
    summary: Dict[str, Any]      # Structured summary of the expense report


class EmailContent(TypedDict):
    """Represents the content of an approval email.
    
    This class defines the structure of the email content that is
    generated by the OpenAI API and returned to the user.
    """
    subject: str                 # Email subject line
    body: str                    # Email body text
    recipient: str               # Email recipient
    approval_status: str         # Approval status (Approved, Needs Review, Rejected)
    approval_comments: str       # Comments explaining the approval decision


# Define workflow nodes - each node is a function that processes part of the workflow
# Each node returns only the fields that have changed, not the entire state
def analyze_expense_summary(state: WorkflowState) -> Dict[str, Any]:
    """
    Analyze the expense report summary to validate it before processing.
    
    This is the first node in the workflow. It checks if the expense summary
    contains valid data before proceeding to the next step.
    
    Args:
        state: The current graph state containing the expense summary
        
    Returns:
        Dictionary with updated state fields (only the error field in this case)
    """
    try:
        # Extract the expense summary from the state
        # The get() method safely returns an empty dict if the key doesn't exist
        expense_summary = state.get("expense_summary", {})
        
        # Check if the summary is valid by ensuring it exists and has content
        # This prevents processing empty or malformed data
        if not expense_summary or not expense_summary.get("summary"):
            return {"error": "Invalid expense summary: Missing or empty summary"}
        
        # If analysis passes, clear any previous errors to indicate success
        # An empty error string means the validation passed
        return {"error": ""}
        
    except Exception as e:
        # Catch any unexpected errors and return them as part of the state
        # This ensures errors are properly handled by the workflow
        return {"error": f"Error analyzing expense summary: {str(e)}"}


def generate_approval_email(state: WorkflowState) -> Dict[str, Any]:
    """
    Generates an approval email based on the expense summary using OpenAI.
    
    This is the second node in the workflow. It takes the validated expense summary
    and uses OpenAI's GPT-4 model to generate a professional approval email with
    a structured format and appropriate approval recommendation.
    
    Args:
        state: The current graph state containing the validated expense summary
        
    Returns:
        Dictionary with updated state fields (email_content and error)
    """
    try:
        # Check if we have an API key in the environment variables
        # This is a security best practice - never hardcode API keys in source code
        api_key = os.environ.get("OPENAI_API_KEY")
        if not api_key:
            # If no API key is found, return an error message
            return {"error": "OpenAI API key not found. Set the OPENAI_API_KEY environment variable."}
        
        # Initialize the OpenAI client with the API key
        # This client will be used to make API calls to OpenAI
        client = OpenAI(api_key=api_key)
        
        # Get the expense summary from the state
        # This contains all the information extracted from the expense report
        expense_summary = state.get("expense_summary", {})
        
        # Extract the text report content from the expense summary
        # This is the human-readable summary of the expense report
        report_content = expense_summary.get("text_report_content", "")
        report_extract = expense_summary.get("summary", {})
        
        # Create a detailed prompt for OpenAI to generate the approval email
        # The prompt includes instructions on what to include in the email and how to format it
        # f-strings allow us to insert the report_content variable into the prompt
        prompt = f"""
        Generate a professional email for expense report approval based on the following expense report discovery summary:
        
        report_content:
        {report_content}
        
        report_extract:
        {report_extract}
        
        The email should include:
        1. A professional subject line
        2. A brief introduction explaining the purpose of the email
        3. A clearly formatted expense summary using plain text formatting only (NO HTML). Format it as follows:
           
           Expense Category | Date   | Amount (R$) | Vendor
           -----------------|--------|-------------|-------
           [Category 1]     | [Date] | [Amount]    | [Vendor]
           [Category 2]     | [Date] | [Amount]    | [Vendor]
           -----------------|--------|-------------|-------
           TOTAL            |        | [Total]     |
           
        4. A summary of the total expense amount
        5. A recommendation for approval or further review
        6. A polite closing
        
        Format the response as a JSON with the following fields:
        - subject: The email subject line
        - body: The email body text in plain text format only (NO HTML tags)
        - recipient: "Finance Department"
        - approval_status: Either "Approved", "Needs Review", or "Rejected"
        - approval_comments: Brief justification for the approval status
        
        IMPORTANT: Do not include any HTML tags in the body. Use only plain text formatting with spaces, dashes, and pipe characters for the table.
        """
        
        # Call the OpenAI API to generate the email content
        # We use the chat completions API with GPT-4 model
        # The system message sets the context for the AI
        # The user message contains our detailed prompt
        response = client.chat.completions.create(
            model="gpt-4",  # Using GPT-4 for high-quality, structured responses
            messages=[
                # System message defines the AI's role and output format
                {"role": "system", "content": "You are an AI assistant that generates professional approval emails for expense reports. Return your response as a valid JSON object with fields for subject, body, recipient, approval_status, and approval_comments."},
                # User message contains our detailed prompt with the expense report data
                {"role": "user", "content": prompt}
            ]
            # Note: response_format parameter was removed as it's not supported by all models
        )
        
        # Parse the response from OpenAI into a structured email content object
        try:
            # First, extract the raw content from the API response
            # The response structure has choices[0].message.content which contains the generated text
            raw_content = response.choices[0].message.content
            
            # Sanitize the JSON string to handle control characters that can cause parsing errors
            # Control characters like newlines (\n), carriage returns (\r), and tabs (\t) can break JSON parsing
            # We replace them with spaces to maintain readability while ensuring valid JSON
            sanitized_content = raw_content.replace('\n', ' ').replace('\r', ' ').replace('\t', ' ')
            
            # Try to parse the sanitized JSON string
            try:
                # json.loads converts a JSON string into a Python dictionary
                email_content = json.loads(sanitized_content)
            except json.JSONDecodeError:
                # If standard parsing fails, try a more aggressive approach
                # Sometimes the AI might include text before or after the JSON object
                # We use regex to extract just the content between curly braces
                import re
                
                # This regex pattern looks for content between { and }, including nested braces
                # The re.DOTALL flag allows the pattern to match across multiple lines
                json_match = re.search(r'\{.*\}', sanitized_content, re.DOTALL)
                
                if json_match:
                    # If we found a match, extract it and try to parse it as JSON
                    email_content = json.loads(json_match.group(0))
                else:
                    # If we still can't find valid JSON, raise an error
                    raise json.JSONDecodeError("Could not extract valid JSON", sanitized_content, 0)
            
            # Validate the parsed JSON to ensure it has all required fields
            # This prevents errors later when trying to access missing fields
            required_fields = ["subject", "body", "recipient", "approval_status", "approval_comments"]
            
            # Check each required field and provide a default value if missing
            for field in required_fields:
                if field not in email_content:
                    email_content[field] = f"Missing {field}"
            
            # Return the successfully parsed email content and clear any previous errors
            return {
                "email_content": email_content,  # The structured email content
                "error": ""                     # Empty error string indicates success
            }
            
        except json.JSONDecodeError as e:
            # If JSON parsing fails, we still want to provide a usable response
            # Rather than failing completely, we create a structured error email
            # This is an example of graceful error handling - providing a fallback
            # that allows the workflow to continue even when things go wrong
            email_content = {
                "subject": "Error Processing Expense Report",
                "body": f"There was an error generating the approval email: {str(e)}\n\nRaw response: {response.choices[0].message.content}",
                "recipient": "Finance Department",
                "approval_status": "Needs Review",  # Default to 'Needs Review' when errors occur
                "approval_comments": "Error in AI processing. Please review manually."
            }
            
            # Return both the fallback email content and the error message
            # This allows the workflow to continue while also logging the error
            return {
                "email_content": email_content,  # Fallback email content
                "error": f"JSON parsing error: {str(e)}"  # Detailed error message for logging
            }
        
    except Exception as e:
        # This is a catch-all for any other unexpected errors that might occur
        # It ensures that the workflow doesn't crash completely if something goes wrong
        # Note that we only return the error message, not email_content,
        # which will trigger the error handling node in the workflow
        return {"error": f"Error in generate_approval_email: {str(e)}"}


def handle_error(state: WorkflowState) -> Dict[str, Any]:
    """
    Handles errors that occur during the workflow execution.
    
    This is a dedicated error handling node in the workflow. It receives the state
    when an error occurs in any other node and provides a graceful fallback response
    rather than failing completely. This ensures that the workflow always produces
    some usable output, even when errors occur.
    
    Args:
        state: The current graph state containing the error message
        
    Returns:
        Dictionary with error handling results including fallback email content
    """
    # Extract the error message from the state, defaulting to "Unknown error" if not present
    # This ensures we always have some error message to work with
    error_msg = state.get("error", "Unknown error")
    
    # Log the error to the console for debugging purposes
    # This is important for troubleshooting issues in production
    print(f"Error in workflow: {error_msg}")
    
    # Create a fallback email content that can be returned to the user
    # This ensures the workflow produces usable output even when errors occur
    fallback_email = {
        "subject": "Error Processing Expense Report",
        "body": f"There was an error in the expense report processing workflow: {error_msg}\n\nPlease review the expense report manually.",
        "recipient": "Finance Department",
        "approval_status": "Needs Review",  # Always set to 'Needs Review' for errors
        "approval_comments": "Workflow error occurred. Manual review required."
    }
    
    # Return both the fallback email content and the original error message
    # This allows the workflow to complete while preserving error information
    return {
        "email_content": fallback_email,  # Structured fallback email content
        "error": error_msg               # Preserve the original error for logging
    }


# Conditional edge functions - these determine the flow of the workflow based on state
# In LangGraph, conditional edges allow dynamic routing between nodes
def should_generate_email(state: WorkflowState) -> str:
    """
    Decides whether to proceed to email generation or error handling after analysis.
    
    This function examines the current state after the analyze_expense_summary node
    and determines which node to execute next based on whether an error occurred.
    
    Args:
        state: The current workflow state
        
    Returns:
        String indicating the next node to execute ('handle_error' or 'generate_approval_email')
    """
    # Check if there's an error in the state
    # If there is an error, route to the error handling node
    # Otherwise, proceed to the email generation node
    return "handle_error" if state.get("error") else "generate_approval_email"


def should_end_or_error(state: WorkflowState) -> str:
    """
    Decides whether to end the workflow or handle an error after email generation.
    
    This function examines the current state after the generate_approval_email node
    and determines whether to end the workflow or route to error handling.
    
    Args:
        state: The current workflow state
        
    Returns:
        String indicating the next node to execute ('handle_error' or END constant)
    """
    # Check if there's an error in the state
    # If there is an error, route to the error handling node
    # Otherwise, end the workflow successfully
    # END is a special constant in LangGraph that indicates workflow completion
    return "handle_error" if state.get("error") else END


# Build the graph with proper LangGraph compliance
def build_graph() -> StateGraph:
    """
    Builds the workflow graph that defines the processing flow.
    
    This function creates a directed graph using LangGraph's StateGraph class.
    The graph defines the nodes (processing functions), edges (connections between nodes),
    and conditional logic that determines the flow of execution based on the state.
    
    Returns:
        StateGraph: A configured workflow graph ready for compilation and execution
    """
    # Create a new StateGraph with our WorkflowState type
    # This ensures type safety throughout the workflow
    workflow = StateGraph(WorkflowState)
    
    # Add the processing nodes to the graph
    # Each node is a function that processes part of the workflow
    workflow.add_node("analyze_expense_summary", analyze_expense_summary)  # First node - validates expense summary
    workflow.add_node("generate_approval_email", generate_approval_email)  # Second node - generates email
    workflow.add_node("handle_error", handle_error)                      # Error handling node
    
    # Define the entry point of the workflow
    # This is the first node that will be executed when the workflow runs
    workflow.set_entry_point("analyze_expense_summary")
    
    # Add conditional edges from the analyze_expense_summary node
    # The should_generate_email function determines which node to execute next
    workflow.add_conditional_edges(
        "analyze_expense_summary",                # Source node
        should_generate_email,                   # Decision function
        {                                        # Mapping of decision results to target nodes
            "generate_approval_email": "generate_approval_email",  # If no error, go to email generation
            "handle_error": "handle_error"                       # If error, go to error handling
        }
    )
    
    # Add conditional edges from the generate_approval_email node
    # The should_end_or_error function determines whether to end or handle an error
    workflow.add_conditional_edges(
        "generate_approval_email",                # Source node
        should_end_or_error,                     # Decision function
        {                                        # Mapping of decision results to target nodes
            END: END,                            # If no error, end the workflow
            "handle_error": "handle_error"       # If error, go to error handling
        }
    )
    
    # Add a direct edge from the handle_error node to END
    # This ensures the workflow always terminates after error handling
    workflow.add_edge("handle_error", END)
    
    # Return the configured workflow graph
    return workflow


def run_agentic_auditor(expense_summary: ExpenseSummary) -> Dict[str, Any]:
    """
    Main entry point for the agentic auditor workflow.
    
    This function serves as the public API for the workflow. It takes an expense summary,
    builds and runs the workflow graph, and returns the results. It also handles
    prerequisite checks and top-level error handling.
    
    Args:
        expense_summary: The structured summary from the ExpenseAuditor containing
                         the expense report data and analysis results
        
    Returns:
        Dict containing the workflow results, including the generated email content
              and any error messages
    """
    try:
        # Check for OpenAI API key early to fail fast if it's missing
        # This prevents unnecessary processing if we know we can't complete the workflow
        if not os.environ.get("OPENAI_API_KEY"):
            # Return a structured error response that matches our expected output format
            # This allows the calling code to handle the error gracefully
            return {
                "email_content": {
                    "subject": "Error: OpenAI API Key Missing",
                    "body": "Unable to generate approval email because the OpenAI API key is missing. Please configure your OpenAI API key in the .env file.",
                    "recipient": "System Administrator",
                    "approval_status": "Error",
                    "approval_comments": "OpenAI API key configuration required."
                },
                "error": "OpenAI API key is missing. Please provide an API key."
            }
        
        # Build and compile the workflow graph
        # build_graph() creates the graph structure
        # compile() converts it to an executable workflow
        workflow = build_graph()
        app = workflow.compile()
        
        # Initialize the workflow state with the expense summary
        # This state will flow through the workflow and be updated by each node
        initial_state: WorkflowState = {
            "expense_summary": expense_summary,  # Input data from ExpenseAuditor
            "email_content": {},               # Will be populated by generate_approval_email
            "error": ""                        # Empty string means no errors initially
        }
        
        # Run the workflow with the initial state
        # This executes the entire graph from entry point to end
        result = app.invoke(initial_state)
        
        # Extract and return the relevant results from the final state
        # This provides a clean API that hides the internal state structure
        return {
            "email_content": result.get("email_content", {}),  # The generated email content
            "error": result.get("error", "")                # Any error that occurred
        }
        
    except Exception as e:
        # Handle any unexpected errors that weren't caught by the workflow's error handling
        # This is a top-level exception handler that ensures we always return a valid response
        
        # Get the full stack trace for detailed debugging
        # traceback.format_exc() returns a string containing the full traceback
        error_trace = traceback.format_exc()
        
        # Log the error to the console for debugging
        # Include both the error message and the full stack trace
        print(f"Workflow execution error: {str(e)}")
        print(error_trace)
        
        # Return a structured error response that matches our expected output format
        # This ensures consistent error handling throughout the application
        return {
            "email_content": {
                "subject": "Error Processing Expense Report",
                "body": f"There was an error in the workflow execution: {str(e)}\n\nPlease review the expense report manually.",
                "recipient": "Finance Department",
                "approval_status": "Needs Review",  # Always set to 'Needs Review' for errors
                "approval_comments": "Workflow execution error. Manual review required."
            },
            "error": f"Workflow execution error: {str(e)}"  # Include the error message for logging
        }


def process_expense_report(pdf_path: str) -> Dict[str, Any]:
    """
    Process an expense report PDF and generate an approval email.
    
    This function serves as a high-level convenience function that combines
    the expense auditing and email generation steps. It takes a PDF file path,
    processes it with the ExpenseAuditor, and then passes the results to the
    agentic workflow for email generation.
    
    Args:
        pdf_path: Path to the PDF expense report file to process
        
    Returns:
        Dict containing the audit results, generated email, and any error messages
    """
    try:
        # Step 1: Create an ExpenseAuditor instance and process the expense report
        # The ExpenseAuditor handles the extraction of information from the PDF
        # using LayoutLMv3 model and OCR (currently using English language data)
        auditor = ExpenseAuditor()
        
        # Process the PDF and get structured audit results
        # This includes extracting monetary values, dates, and expense categories
        audit_results = auditor.audit_expense_report(pdf_path)
        
        # Step 2: Run the agentic workflow to generate an approval email
        # The workflow analyzes the audit results and generates a professional email
        workflow_results = run_agentic_auditor(audit_results)
        
        # Step 3: Combine the results from both steps into a single response
        # This provides a complete picture of the processing results
        return {
            "audit_results": audit_results,                    # Results from ExpenseAuditor
            "email": workflow_results["email_content"],       # Generated email content
            "error": workflow_results["error"]                # Any errors that occurred
        }
        
    except Exception as e:
        # Handle any unexpected errors that occur during processing
        # This ensures we always return a structured response even if processing fails
        return {
            "audit_results": {},  # Empty audit results since processing failed
            "email": {
                "subject": "Error Processing Expense Report",
                "body": f"There was an error processing the expense report: {str(e)}",
                "recipient": "System Administrator",
                "approval_status": "Error",
                "approval_comments": "Processing error occurred."
            },
            "error": f"Error processing expense report: {str(e)}"  # Include the error message
        }


def main():
    """
    Main entry point for command-line execution.
    
    This function provides a command-line interface for processing expense reports.
    It parses command-line arguments, processes the specified PDF file, and displays
    the results in a user-friendly format.
    """
    # Set up command-line argument parsing
    # This allows users to specify the PDF file path as a command-line argument
    parser = argparse.ArgumentParser(description="Process an expense report and generate an approval email.")
    parser.add_argument("pdf_path", help="Path to the PDF expense report")
    args = parser.parse_args()
    
    # Process the expense report using the specified PDF path
    # This calls our high-level processing function that handles both
    # expense extraction and email generation
    results = process_expense_report(args.pdf_path)
    
    # Check for errors and display appropriate output
    if results["error"]:
        # If there was an error, display it to the user
        print(f"Error: {results['error']}")
    else:
        # If processing was successful, display the results
        print("Expense report processed successfully!")
        
        # Print the generated email details in a readable format
        # This provides immediate feedback on the processing results
        email = results["email"]
        print("\nGenerated Email:")
        print(f"Subject: {email['subject']}")
        print(f"Recipient: {email['recipient']}")
        print(f"Approval Status: {email['approval_status']}")
        print(f"\nBody:\n{email['body']}")
        print(f"\nComments: {email['approval_comments']}")


# Standard Python idiom to check if this file is being run directly
# This allows the file to be both imported as a module and run as a script
if __name__ == "__main__":
    # If this file is being run directly, execute the main function
    main()